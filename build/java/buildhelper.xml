<?xml version="1.0"?>
<!--
 Copyright (c) 2008 by Vlideshow Inc. (a.k.a. The Yard).  All rights reserved.
 
 It is REQUESTED BUT NOT REQUIRED if you use this library, that you let 
 us know by sending e-mail to info\@theyard.net telling us briefly how you're
 using the library and what you like or don't like about it.

 This library is free software; you can redistribute it and/or modify it under the
 terms of the GNU Lesser General Public License as published by the Free Software
 Foundation; either version 2.1 of the License, or (at your option) any later
 version.

 This library is distributed in the hope that it will be useful, but WITHOUT ANY
 WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.

 You should have received a copy of the GNU Lesser General Public License along
 with this library; if not, write to the Free Software Foundation, Inc.,
 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
-->
<project
  name="xuggle-buildhelper"
  default="dist"
  basedir="."
  xmlns:ivy="antlib:org.apache.ivy.ant"
  >
  <description>
    This build file is a generic build file meant to be
    imported by other builds.  It has the standard rules
    used by the Yard build system.

    Callers must define the following properites BEFORE importing:

    library.version.major: An integer less than 65536
    library.version.minor: An integer less than 256 (don't ask).
  </description>

  <property file="mk/buildtools/build.properties"/>
  <property name="app.name" value="${ant.project.name}"/>
  <property name="documentation.title" value="${ant.project.name}"/>

  <property environment="env"/>
  <property name="top.dir" location="."/>
  <property name="src.dir" location="src"/>
  <property name="build.dir" location="build"/>
  <property name="nativebuild.dir" location="${build.dir}/native"/>
  <property name="classes.dir" location="${build.dir}/classes"/>
  <property name="generated.src.dir" location="generated/java"/>
  <property name="dist.dir" location="dist"/>

  <available property="share.exists" file="share/build.xml"/>

  <!-- Load up the ant-contrib tasks because I'm sick
    of not having if/else/then -->
  <taskdef resource="net/sf/antcontrib/antlib.xml"
    classpath="mk/buildtools/lib/ant-contrib.jar"/>

  <condition property="os.windows">
    <os family="windows"/>
  </condition>
  <condition property="os.mac">
    <os family="mac"/>
  </condition>
  <condition property="os.unix">
    <and>
      <os family="unix"/>
      <not>
        <os family="mac"/>
      </not>
    </and>
  </condition>

  <property name="ivy.lib.dir" value="${build.dir}/lib"/>
  <property name="ivy.version" value="ivy-2.0.0-beta2" />
  <property name="ivy.retrieve.pattern" value="${ivy.lib.dir}/[conf]/[artifact].[ext]" />

  <!-- JUnit Test stuff -->
  <property name="test.dir" value="test"/>
  <property name="test.src.dir" value="${test.dir}/src"/>
  <property name="test.src.fixtures.dir" value="${test.dir}/fixtures"/>
  <property name="test.classes.dir" value="${build.dir}/test"/>
  <property name="test.reports.dir" value="${test.classes.dir}/output"/>
  <property name="test.fixtures.dir" value="${test.reports.dir}/fixtures"/>
  <property name="testdoc.dir" value="doc/test"/>
  <property name="test.show_output" value="${env.VS_TEST_SHOW_OUTPUT}"/>

  <!-- Javadoc properties -->
  <property name="imagedoc.dir" value="doc/images"/>
  <property name="javadoc.dir" value="doc/java/api"/>

  <path id="project.classpath">
    <fileset dir="${build.dir}/lib/default">
      <include name="**/*.jar"/>
      <exclude name="ivy*.jar"/>
    </fileset>
  </path>
  <path id="compile.classpath">
    <pathelement location="${classes.dir}"/>
    <fileset dir="${build.dir}/lib/compile">
      <include name="**/*.jar"/>
      <exclude name="ivy*.jar"/>
    </fileset>
    <pathelement location="${env.RED5_HOME}/red5.jar"/>
  </path>
  <path id="test.classpath">
    <pathelement location="${classes.dir}"/>
    <pathelement location="${test.classes.dir}"/>
    <fileset dir="${build.dir}/lib/test">
      <include name="**/*.jar"/>
      <exclude name="ivy*.jar"/>
    </fileset>
    <pathelement location="${env.RED5_HOME}/red5.jar"/>
  </path>

  <target name="java6.check">
    <condition property="java6.installed" value="true">
      <and>
        <equals arg1="${java.target_version}" arg2="1.6"/>
        <available property="java6.installed" classname="javax.script.Bindings"/>
      </and>
    </condition>

    <condition property="java6.using" value="1.6" else="${java.target_version}">
      <isset property="java6.installed"/>
    </condition>
    <echo message='Java: java.home is ${java.home} and the target version is ${java.target_version}'/>
    <echo message='Ant: ant.home is ${ant.home} and the target version is ${ant.version}'/>
  </target>

  <target name="ivy-init" unless="xuggle.ivy.initted">
    <!--
    Ivy tasks and lib directory
    http://ant.apache.org/ivy
    http://testearly.com/2007/06/24/ivy-in-42-steps

    In order for this to work, you need to set the right ivy JAR file into
    the lib directory of your project; all other dependencies are then managed
    by that jar file.
    -->
    <echo message="Initing ivy from mk/buildtools/lib/${ivy.version}.jar"/>
    <taskdef uri="antlib:org.apache.ivy.ant" resource="org/apache/ivy/ant/antlib.xml" classpath="mk/buildtools/lib/${ivy.version}.jar"/>
    <property name="xuggle.ivy.initted" value="true"/>
    <echo message="Ivy task loaded"/>
    <ivy:settings override="true" file="mk/buildtools/ivysettings.xml"/>
    <echo message="Ivy settings file set"/>
  </target>

  <target name="ivy-publish"
    depends="ivy-init"
    description="Publish any libraries">
    <!-- Ivy configuration -->
    <condition property="ivy.settings.name" value="default">
      <not>
        <isset property="ivy.settings.name"/>
      </not>
    </condition>
    <echo message="ivy.settings.name: ${ivy.settings.name}"/>
    <ivy:resolve file="ivy.xml" conf="${ivy.settings.name}"/>
    <ivy:retrieve file="ivy.xml" conf="${ivy.settings.name}"/>
    <ivy:publish
      update="true"
      replacedynamicrev="false"
      forcedeliver="true"
      overwrite="true"
      pubrevision="${library.version.major}.${library.version.minor}.${library.revision}"
      resolver="publish">
      <artifacts pattern="${dist.dir}/lib/[artifact].[ext]" />
    </ivy:publish>
  </target>

  <target name="clean-share"
    if="share.exists"
    description="Clean all share objects">
    <ant dir="share" target="clean" inheritAll="false" />
  </target>

  <target name="clobber-share"
    if="share.exists"
    description="Clobber all share objects">
    <ant dir="share" target="clobber" inheritAll="false" />
  </target>

  <target name="install-share"
    if="share.exists"
    description="Install all share libraries">
    <ant dir="share" target="install" inheritAll="false" />
  </target>

  <target name="uninstall-share"
    if="share.exists"
    description="Install all share libraries">
    <ant dir="share" target="uninstall" inheritAll="false" />
  </target>

  <target name="windows-init"
    if="os.windows">
    <condition property="env.XUGGLE_HOME" value="c:/msys/local">
      <not>
        <isset property="env.XUGGLE_HOME"/>
      </not>
    </condition>

    <condition property="env.PATH" value="">
      <not>
        <isset property="env.PATH"/>
      </not>
    </condition>

    <property name="xuggle.dir.native" value="${env.XUGGLE_HOME}"/>
    <if>
      <not>
        <available file="${xuggle.dir.native}"/>
      </not>
      <then>
        <fail message="ERRROR: ${xuggle.dir.native} must already exist for the build to work"/>
      </then>
    </if>
    <unix-pathconvert property="xuggle.dir" path="${xuggle.dir.native}"/>

    <property name="runtime.so.path.variable" value="PATH"/>
    <property name="runtime.so.path.origvalue" value="${env.PATH}"/>
    <property name="runtime.so.path.directory" value="bin"/>
    <echo message="Converted windows path: '${env.XUGGLE_HOME}' to short name: '${xuggle.dir.native}' and UNIX name: '${xuggle.dir}'" />
  </target>
  <target name="mac-init"
    if="os.mac">
    <condition property="env.XUGGLE_HOME" value="/usr/local">
      <not>
        <isset property="env.XUGGLE_HOME"/>
      </not>
    </condition>

    <condition property="env.DYLD_LIBRARY_PATH" value="">
      <not>
        <isset property="env.DYLD_LIBRARY_PATH"/>
      </not>
    </condition>

    <path id="xuggle.dir.path">
      <pathelement location="${env.XUGGLE_HOME}"/>
    </path>
    <property name="xuggle.dir.native" refid="xuggle.dir.path"/>
    <property name="xuggle.dir" value="${xuggle.dir.native}"/>

    <property name="runtime.so.path.variable" value="DYLD_LIBRARY_PATH"/>
    <property name="runtime.so.path.origvalue" value="${env.DYLD_LIBRARY_PATH}"/>
    <property name="runtime.so.path.directory" value="lib"/>
  </target>
  <target name="unix-init"
    if="os.unix">
    <condition property="env.XUGGLE_HOME" value="/usr/local">
      <not>
        <isset property="env.XUGGLE_HOME"/>
      </not>
    </condition>

    <condition property="env.LD_LIBRARY_PATH" value="">
      <not>
        <isset property="env.LD_LIBRARY_PATH"/>
      </not>
    </condition>

    <path id="xuggle.dir.path">
      <pathelement location="${env.XUGGLE_HOME}"/>
    </path>
    <property name="xuggle.dir.native" refid="xuggle.dir.path"/>
    <property name="xuggle.dir" value="${xuggle.dir.native}"/>

    <property name="runtime.so.path.variable" value="LD_LIBRARY_PATH"/>
    <property name="runtime.so.path.origvalue" value="${env.LD_LIBRARY_PATH}"/>
    <property name="runtime.so.path.directory" value="lib"/>
  </target>

  <target name="os-init"
    depends="windows-init, mac-init, unix-init">
  </target>

  <target name="init" depends="os-init, java6.check, ivy-init" >
    <!-- Create the time stamp -->
    <tstamp/>

    <!-- Create the build directory structure used by compile -->
    <mkdir dir="${build.dir}"/>
    <mkdir dir="${test.classes.dir}"/>
    <mkdir dir="${test.reports.dir}"/>
    <mkdir dir="${test.fixtures.dir}"/>

    <!-- Get the SVN Revision if available -->
    <exec executable="sh"
      dir="${top.dir}"
      failonerror="false"
      failifexecutionfails="false">
      <arg value="${top.dir}/mk/buildtools/revision.sh"/>
      <arg value="${top.dir}"/>
      <arg value="${top.dir}LastRevisionBuilt.txt"/>
      <arg value="/dev/null"/>
      <arg value="${build.dir}/Revision.properties"/>
    </exec>
    <!-- And read it -->
    <property file="${build.dir}/Revision.properties"/>
    <condition property="library.revision" value="0">
      <not>
        <isset property="library.revision"/>
      </not>
    </condition>
    <echo message="Building Library Version: ${library.version.major}.${library.version.minor}.${library.revision}"/>

    <!-- Get the native OS name, if available -->
    <exec executable="sh"
      dir="${top.dir}"
      failonerror="false"
      output="${build.dir}/OS.properties"
      failifexecutionfails="false">
      <arg value="${top.dir}/mk/buildtools/guess_os.sh"/>
      <arg value="${top.dir}"/>
    </exec>
    <!-- And read it -->
    <property file="${build.dir}/OS.properties"/>
    <condition property="xuggle.os" value="${os.name}">
      <not>
        <isset property="xuggle.os"/>
      </not>
    </condition>
    <echo message="Building for OS: ${xuggle.os}" />
    <property name="build-native.dir" location="${build.dir}/native/${xuggle.os}"/>
    <mkdir dir="${build-native.dir}"/>
    <if>
      <isset property="os.windows"/>
      <then>
        <unix-pathconvert property="build-native.unix.dir" path="${build-native.dir}"/>
      </then>
      <else>
        <property name="build-native.unix.dir" value="${build-native.dir}"/>
      </else>
    </if>
    <!-- Set the runtime library path to contain both
      the captive installation directory (used during build)
      and the actual installation directory -->
      <!--
    <property name="runtime.so.path.value"
      value="${build-native.dir}${file.separator}captive${xuggle.dir}${file.separator}${runtime.so.path.directory}${path.separator}${xuggle.dir.native}${file.separator}${runtime.so.path.directory}${path.separator}${runtime.so.path.origvalue}"/>
    -->
    <property name="runtime.so.path.value"
      value="${build-native.dir}${file.separator}captive${xuggle.dir}${file.separator}${runtime.so.path.directory}${path.separator}${xuggle.dir.native}${file.separator}${runtime.so.path.directory}"/>
    <property name="runtime.java.library.path"
      value="${build-native.dir}${file.separator}captive${xuggle.dir}${file.separator}${runtime.so.path.directory}${path.separator}${xuggle.dir.native}${file.separator}${runtime.so.path.directory}"/>
  </target>

  <target name="ivy-retrieve" 
    description="Retrieves the libraries if needed">
    <!-- Ivy configuration -->
    <condition property="ivy.settings.name" value="default">
      <not>
        <isset property="ivy.settings.name"/>
      </not>
    </condition>
    <mkdir dir="${build.dir}/lib"/>
    <echo message="ivy.settings.name: ${ivy.settings.name}"/>
    <ivy:resolve file="ivy.xml" conf="${ivy.settings.name}"/>
    <ivy:retrieve file="ivy.xml" conf="${ivy.settings.name}"/>
  </target>

  <target name="ivy-clear" description="Clears out the Ivy cache">
    <delete verbose="true" failonerror="false" dir="${user.home}/.ivy/cache"/>
    <delete verbose="true" failonerror="false" dir="${user.home}/.ivy2/cache"/>
    <delete verbose="true" failonerror="false" includeemptydirs="true">
      <fileset dir="${build.dir}/lib" excludes="**/ivy*.jar"/>
    </delete>
  </target>

  <target name="compile-java" depends="init"
    description="compile the source " >
    <antcall target="ivy-retrieve" inheritAll="true" inheritRefs="true">
      <param name="ivy.settings.name" value="compile"/>
    </antcall>
    <mkdir dir="${classes.dir}"/>
    <mkdir dir="${generated.src.dir}"/>
    <!-- Update any Java template files-->
    <echo message="Generating Java source from templates"/>
    <copy todir="${generated.src.dir}">
      <fileset dir="${src.dir}">
        <include name="**/*.java.in"/>
      </fileset>
      <filterset>
        <filter token="LIB_MAJOR_VERSION" value="${library.version.major}"/>
        <filter token="LIB_MINOR_VERSION" value="${library.version.minor}"/>
      </filterset>
      <globmapper from="*.java.in" to="*.java"/>
    </copy>
    <!-- Compile the java code from ${src.dir} into ${build.dir} -->
    <javac
      source="${java.source}"
      destdir="${classes.dir}"
      classpathref="compile.classpath"
      optimize="${build.optimize}"
      verbose="${build.verbose}"
      fork="${build.fork}"
      nowarn="${build.nowarn}"
      deprecation="${build.deprecation}"
      debug="${debug.state}"
      debuglevel="${debug.level}"
      listfiles="${build.listfiles}">
      <src path="${generated.src.dir}"/>
      <src path="${src.dir}"/>
      <compilerarg line="${build.extraflags}"/>
    </javac>
  </target>

  <target name="dist-java"
    depends="compile-java, fixtures-java"
    description="generate the distribution" >
    <!-- Create the distribution directory -->
    <antcall target="ivy-retrieve" inheritAll="true" inheritRefs="true">
      <param name="ivy.settings.name" value="default"/>
    </antcall>
    <mkdir dir="${dist.dir}/lib"/>
    <!-- Copy over all the Jar files we need -->
    <copy todir="${dist.dir}/lib">
      <fileset dir="${build.dir}/lib/default">
        <include name="**/*.jar"/>
      </fileset>
    </copy>
    <if>
      <not>
        <isset property="manifest.classpath"/>
      </not>
      <then>
        <manifestclasspath
          property="manifest.classpath"
          jarfile="${dist.dir}/lib/${app.name}.jar"
          >
          <classpath>
            <fileset dir="${dist.dir}/lib">
              <include name="**/*.jar"/>
              <exclude name="${app.name}.jar"/>
            </fileset>
          </classpath>
        </manifestclasspath>
      </then>
    </if>
    <jar jarfile="${dist.dir}/lib/${app.name}.jar"
      index="no"
      basedir="${classes.dir}">
      <manifest>
        <attribute name="Implementation-Vendor" value="www.xuggle.com"/>
        <attribute name="Implementation-Title" value="${app.name}"/>
        <attribute name="Implementation-Version" value="${library.version.major}.${library.version.minor}.${library.revision}"/>
        <attribute name="Class-Path" value="${manifest.classpath}"/>
        <attribute name="Main-Class" value="${app.mainclass}"/>
      </manifest>
    </jar>
  </target>

  <target name="install-java" depends="dist-java"
    description="publishes the jar file to XUGGLE_HOME">
    <antcall target="ivy-publish" inheritAll="true" inheritRefs="true">
      <param name="ivy.settings.name" value="default"/>
    </antcall>
    <mkdir dir="${xuggle.dir.native}/share/java/jars"/>
    <copy todir="${xuggle.dir.native}/share/java/jars">
      <fileset dir="${dist.dir}/lib">
        <include name="**/*.jar"/>
      </fileset>
    </copy>
    <antcall target="install-share" inheritAll="true" inheritRefs="true"/>
    <antcall target="install-red5" inheritAll="true" inheritRefs="true"/>
  </target>

  <target name="uninstall-java"
    depends="init"
    description="uninstalls any installed jar files from XUGGLE_HOME">
    <delete
      failonerror="false"
      includeemptydirs="true"
      verbose="true"
      dir="${xuggle.dir.native}/share/xuggle/java/${app.name}"/>
    <antcall target="uninstall-share"/>
    <antcall target="uninstall-red5"/>
  </target>

  <target name="clobber-java" depends="init, clobber-share, clean-java"
    description="Cleans everything; make sure you can regenerate if needed">
    <delete failonerror="false" dir="${build.dir}"/>
    <delete failonerror="false" dir="${javadoc.dir}"/>
  </target>

  <target name="clean-java" depends="clean-share"
    description="clean up" >
    <!-- Delete the ${build.dir} and ${dist.dir} directory trees -->
    <delete failonerror="false" dir="${classes.dir}"/>
    <delete failonerror="false" dir="${test.classes.dir}"/>
    <delete failonerror="false" dir="${dist.dir}"/>
  </target>

  <target name="fixtures-java" depends="init"
    description="install fixtures needed by tests in the right place">
    <!-- copy over fixtures -->
    <copy todir="${test.fixtures.dir}">
      <fileset dir="${test.src.fixtures.dir}">
        <include name="**/*"/>
      </fileset>
    </copy>
  </target>

  <target name="compile-tests-java" depends="compile-java" description="Compiles junit test classes">
    <antcall target="ivy-retrieve" inheritAll="true" inheritRefs="true">
      <param name="ivy.settings.name" value="test"/>
    </antcall>
    <javac
      source="${java.source}"
      srcdir="${test.src.dir}"
      destdir="${test.classes.dir}"
      classpathref="test.classpath"
      optimize="${build.optimize}"
      verbose="${build.verbose}"
      fork="${build.fork}"
      nowarn="${build.nowarn}"
      deprecation="${build.deprecation}"
      debug="${debug.state}"
      debuglevel="${debug.level}"
      listfiles="${build.listfiles}">
      <compilerarg line="${build.extraflags}"/>
    </javac>
  </target>

  <target name="run-memcheck-java"
    depends="init, compile-tests-java, fixtures-java"
    description="run memory check test suite for Java if available">
  </target>

  <target name="run-tests-java" depends="dist-java, compile-tests, fixtures-java"
    description="Run JUnit tests and generate HTML reports">
    <!-- we fail a test with a timeout if it takes longer than 5 minutes -->
    <echo message='Java: java.home is ${java.home} and the target version is ${java.target_version}'/>
    <echo message="java.library.path=${runtime.java.library.path}"/>
    <echo message="env.${runtime.so.path.variable}=${runtime.so.path.value}"/>
    <junit
      fork="true"
      haltonfailure="no"
      haltonerror="yes"
      printsummary="yes"
      showoutput="${test.show_output}"
      timeout="1800000"
      dir="${test.reports.dir}"
      newenvironment="no"
      >
      <env key="${runtime.so.path.variable}"
        path="${runtime.so.path.value}"/>
      <jvmarg value="-Djava.library.path=${runtime.java.library.path}"/>
      <jvmarg value="-Denv.${runtime.so.path.variable}=${runtime.so.path.value}"/>
      <jvmarg value="-client"/>
      <jvmarg value="-XX:+HeapDumpOnOutOfMemoryError"/>
      <jvmarg value="-Xcheck:jni"/>
      <!-- This line makes sure that Java looks in the build dir for the
      shared library.  -->
      <!--
      <jvmarg value="-verbose:jni"/>
      <jvmarg value="-verbose:gc"/>
      <jvmarg value="-XX:+PrintGCDetails"/>
      <jvmarg value="-XX:+PrintGCTimeStamps"/>
      <jvmarg value="-XX:+PrintTenuringDistribution"/>
      -->
      <classpath>
        <path refid="test.classpath"/>
      </classpath>
      <formatter type="xml"/>
      <batchtest todir="${test.reports.dir}">
        <fileset dir="${test.classes.dir}">
          <include name="**/*Test.class"/>
        </fileset>
      </batchtest>
    </junit>

    <junitreport todir="${test.classes.dir}">
      <fileset dir="${test.reports.dir}">
        <include name="TEST-*.xml"/>
      </fileset>
      <report format="frames" todir="${testdoc.dir}"/>
    </junitreport>

    <echo message="View test results in browser: ${testdoc.dir}/index.html"/>

  </target>

  <target name="doc-java" depends="init, compile-java" description="Generate JavaDoc">
    <!-- Determine the location of Sun's API docs -->
    <condition property="javadoc.loc" value="javase/6">
      <equals arg1="${java6.installed}" arg2="true"/>
    </condition>
    <condition property="javadoc.loc" value="j2se/1.5.0">
      <not>
        <equals arg1="${java6.installed}" arg2="true"/>
      </not>
    </condition>
    <echo message="Javadoc API stub: ${javadoc.loc}"/>
    <javadoc
      overview="doc/java/overview.html"
      useexternalfile="true"
      failonerror="true"
      stylesheetfile="mk/buildtools/javadoc.css"
      verbose="false"
      classpathref="compile.classpath"
      destdir="${javadoc.dir}"
      linksource="yes"
      author="true" version="true"
      Use="true"
      splitindex="true"
      Public="true"
      includenosourcepackages="true"
      windowtitle="${documentation.title}">
      <packageset dir="${generated.src.dir}" defaultexcludes="yes">
      </packageset>
      <packageset dir="${src.dir}" defaultexcludes="yes">
      </packageset>
      <doctitle><![CDATA[<h1>${documentation.title}</h1>]]></doctitle>
      <bottom><![CDATA[<i>Copyright &#169; 2009 <a href="http://www.xuggle.com/" target="_blank">Xuggle</a></i>]]></bottom>
      <link href="http://java.sun.com/${javadoc.loc}/docs/api"/>
      <link href="http://mina.apache.org/report/1.1/apidocs"/>
      <link href="http://static.springframework.org/spring/docs/2.0.x/api"/>
      <link href="http://www.slf4j.org/apidocs/"/>
      <link href="http://logback.qos.ch/apidocs/"/>
      <link href="http://jetm.void.fm/api/"/>
      <link href="http://www.cs.umd.edu/projects/PL/multithreadedtc/docs/"/>
      <link href="http://build.xuggle.com/job/xuggle_java_utils_jdk5_i386_ubuntu/javadoc/java/api/index.html"/>
      <link href="http://build.xuggle.com/job/xuggle_java_xuggler_jdk5_i386_ubuntu/javadoc/java/api/index.html"/>
      <link href="http://build.xuggle.com/job/xuggle_java_xuggler_red5_jdk5_i386_ubuntu/javadoc/java/api/index.html"/>

    </javadoc>
    <!-- copy over any images we keep for documentation to
     overlap the javadoc tree -->
    <copy failonerror="false" todir="${javadoc.dir}">
      <fileset dir="${imagedoc.dir}">
        <include name="**/*"/>
      </fileset>
    </copy>
  </target>

  <target name="uptodate-native"
    depends="init">
    <available property="native.configure.exists"
      file="${top.dir}/configure"/>
    <echo message="${top.dir}/configure exists=${native.configure.exists}"/>
    <available property="native.makefile.exists"
      file="${build-native.dir}/Makefile"/>
    <echo message="${build-native.dir}/Makefile exists=${native.makefile.exists}"/>
  </target>
  <target name="configure-native"
    if="native.configure.exists"
    unless="native.makefile.exists"
    description="Run configure">
    <mkdir dir="${build-native.dir}"/>
    <!-- Default to a 32-bit build -->
    <condition property="build.m64" value="no">
      <not>
        <isset property="build.m64"/>
      </not>
    </condition>
    <!-- Default to a GPL build -->
    <condition property="build.gpl" value="yes">
      <not>
        <isset property="build.gpl"/>
      </not>
    </condition>
    <!-- Yes, Windows is annoying and doesn't do well with
    unescaped paths... so we convert to Unix format -->
    <unix-pathconvert property="top.dir.unix" path="${top.dir}"/>
    <echo message="executing: configure --enable-m64=${build.m64} --enable-gpl=${build.gpl} --prefix='${xuggle.dir}'"/>
    <exec executable="sh"
      dir="${build-native.dir}"
      failonerror="true">
      <arg value="../../../configure"/>
      <arg value="--enable-m64=${build.m64}"/>
      <arg value="--enable-gpl=${build.gpl}"/>
      <arg value="--prefix=${xuggle.dir}"/>
    </exec>
    <available property="native.makefile.exists"
      file="${build-native.dir}/Makefile"/>
    <echo message="${build-native.dir}/Makefile should now exist=${native.makefile.exists}"/>
  </target>
  <target name="init-native"
    depends="uptodate-native, configure-native"
    description="Runs configure in the current directory if Makefile is not up to date"
    >
  </target>
  <target name="compile-native-do"
    if="native.makefile.exists" >
    <exec executable="make"
      dir="${build-native.dir}"
      failonerror="true">
      <arg line="all"/>
    </exec>
  </target>
  <target name="compile-native"
    depends="init-native, compile-native-do"
    description="Builds the native library">
  </target>
  <target name="dist-native-do"
    if="native.makefile.exists">
    <exec executable="make"
      dir="${build-native.dir}"
      failonerror="true">
      <arg line="dist"/>
    </exec>
  </target>
  <target name="dist-native"
    depends="init-native, compile-native, dist-native-do"
    description="Builds the native source distribution">
  </target>
  <target name="dist-native-test-do"
    if="native.makefile.exists">
    <exec executable="make"
      dir="${build-native.dir}"
      failonerror="true">
      <arg line="distcheck"/>
    </exec>
  </target>
  <target name="dist-native-test"
    depends="init-native, dist-native-test-do"
    description="Builds the native source distribution, and makes sure it's complete">
  </target>
  <target name="compile-tests-native-do"
    if="native.makefile.exists">
    <!-- We install a copy of the library into the captive area
         so that any java run-tests that need the library can
         find it there.  -->
    <exec executable="make"
      dir="${build-native.dir}/csrc"
      failonerror="true">
      <arg line="install-exec"/>
      <env key="DESTDIR" value="${build-native.unix.dir}/captive"/>
    </exec>
  </target>
  <target name="compile-tests-native"
    depends="init-native, compile-tests-native-do"
    description="Compiles the native test code">
  </target>
  <target name="install-native-do"
    if="native.makefile.exists">
    <exec executable="make"
      dir="${build-native.dir}"
      failonerror="true">
      <arg line="install"/>
    </exec>
  </target>
  <target name="install-native"
    depends="init-native, install-native-do"
    description="Installs native libraries to $XUGGLE_HOME">
  </target>
  <target name="run-tests-native-do"
    if="native.makefile.exists">
    <exec executable="make"
      dir="${build-native.dir}"
      failonerror="true">
      <arg line="check"/>
    </exec>
  </target>
  <target name="run-tests-native"
    depends="init-native, run-tests-native-do"
    description="Runs the native test suite">
  </target>
  <target name="run-memcheck-native-do"
    if="native.makefile.exists">
    <exec executable="make"
      dir="${build-native.dir}"
      failonerror="true">
      <arg line="memcheck"/>
    </exec>
  </target>
  <target name="run-memcheck-native"
    depends="init-native, run-memcheck-native-do"
    description="Runs the native memory checking suite">
  </target>
  <target name="doc-native-do"
    if="native.makefile.exists">
    <exec executable="make"
      dir="${build-native.dir}"
      failonerror="true">
      <arg line="doc"/>
    </exec>
  </target>
  <target name="doc-native"
    depends="init-native, doc-native-do"
    description="Generate the native documentation">
  </target>
  <target name="clean-native-do"
    if="native.makefile.exists"
    description="Special target that is only called if the Makefile already exists">
    <exec executable="make"
      dir="${build-native.dir}"
      failonerror="true">
      <arg line="clean"/>
    </exec>
  </target>
  <target name="clean-native"
    depends="init-native, clean-native-do"
    description="Cleans the native tree">
  </target>
  <target name="clobber-native"
    depends="init"
    description="Do a complete distribution clean of the native code">
    <!-- We just nuke the build directory where everything should
         be under -->
    <delete failonerror="false" dir="${build-native.dir}"/>
  </target>
  <target name="uninstall-native-do"
    if="native.makefile.exists">
    <exec executable="make"
      dir="${build-native.dir}"
      failonerror="true">
      <arg line="uninstall"/>
    </exec>
  </target>
  <target name="uninstall-native"
    depends="init-native, uninstall-native-do"
    description="Do a complete uninstall of the native code">
  </target>

  <target name="install-red5">
    <!-- Override this target if you want to use it.  It will be
     called when the "install" target is run.  -->
  </target>
  <target name="uninstall-red5">
    <!-- Override this target if you want to use it.  It will
    be called when the "clobber" target is run. -->
  </target>

  <target name="all" depends="run-tests, doc, dist, install"
    description="build everything (including native), run all tests, and build all docs"/>

  <target name="compile"
    depends="compile-native, compile-java"
    description="compile everything, including native code if available"/>
  <target name="compile-tests"
    depends="compile-tests-native, compile-tests-java"
    description="compile everything, including native code if available"/>
  <target name="dist"
    depends="dist-native, dist-java"
    description="dist everything, including native code if available"/>
  <target name="install"
    depends="install-native, install-java"
    description="install everything, including native code if available"/>
  <target name="uninstall"
    depends="uninstall-native, uninstall-java"
    description="uninstall everything, including native code if available"/>
  <target name="clobber"
    depends="clobber-java, clobber-native"
    description="clobber everything, including native code if available"/>
  <target name="clean"
    depends="clean-native, clean-java"
    description="clean everything, including native code if available"/>
  <target name="run-tests"
    depends="run-tests-native, run-tests-java"
    description="Run all tests, including native tests if available"/>
  <target name="run-memcheck"
    depends="run-memcheck-native, run-memcheck-java"
    description="Run all memory tests, including native tests if available"/>
  <target name="doc"
    depends="doc-native, doc-java"
    description="Create all documentation, including native documentation if available"/>

  <!--
  Macros go here.
  -->
  <!-- Two handy macros that can be used inside a "install-red5" target -->
  <macrodef name="uninstall-red5webapp">
    <attribute name="name"/>
    <sequential>
      <delete dir="${env.RED5_HOME}/webapps/@{name}" failonerror="false"/>
    </sequential>
  </macrodef>
  <macrodef name="install-red5webapp">
    <attribute name="name"/>
    <sequential>
      <uninstall-red5webapp name="@{name}"/>
      <mkdir dir="${env.RED5_HOME}/webapps/@{name}/"/>
      <copy todir="${env.RED5_HOME}/webapps/@{name}">
        <fileset dir="web/@{name}/">
          <include name="**/*"/>
        </fileset>
      </copy>
      <mkdir dir="${env.RED5_HOME}/webapps/@{name}/WEB-INF/"/>
      <!-- now copy over the contents of the dist directory -->
      <copy todir="${env.RED5_HOME}/webapps/@{name}/WEB-INF">
        <fileset dir="${dist.dir}">
          <include name="**/*"/>
        </fileset>
      </copy>
      <!-- and make sure we copy over any major jar file -->
      <copy todir="${env.RED5_HOME}/webapps/@{name}/WEB-INF/lib">
        <fileset dir="${dist.dir}">
          <include name="*.jar"/>
        </fileset>
      </copy>
    </sequential>
  </macrodef>
  <!--
    This macro converts a path to a unix path, and makes
    sure that any file names with colons in them (drive 
    letters in windows) are converted to the Msys style
    or cygwin style.

    This is needed to work with captive builds.
    -->
  <macrodef name="unix-pathconvert">
    <attribute name="property"/>
    <attribute name="path"/>
    <sequential>
      <if>
        <available
          file="@{path}"/>
        <then>
          <exec
            executable="sh"
            dir="@{path}"
            outputproperty="@{property}"
            failonerror="false"
            >
            <arg line="pwd -P"/>
          </exec>
        </then>
      </if>
      <if>
        <not>
          <isset property="@{property}"/>
        </not>
        <then>
          <pathconvert os="unix" property="@{property}">
            <path>
              <pathelement location="@{path}"/>
            </path>
          </pathconvert>
        </then>
      </if>
    </sequential>
  </macrodef>
</project>
