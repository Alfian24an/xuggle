/*
 * Copyright (c) 2008, 2009 by Xuggle Incorporated. All rights reserved.
 * 
 * This file is part of Xuggler.
 * 
 * You can redistribute Xuggler and/or modify it under the terms of the GNU
 * Affero General Public License as published by the Free Software Foundation,
 * either version 3 of the License, or (at your option) any later version.
 * 
 * Xuggler is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU Affero General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU Affero General Public License
 * along with Xuggler. If not, see <http://www.gnu.org/licenses/>.
 */

package com.xuggle.mediatool;

import java.awt.image.BufferedImage;
import java.util.concurrent.TimeUnit;

import com.xuggle.xuggler.IPacket;
import com.xuggle.xuggler.IAudioSamples;
import com.xuggle.xuggler.IVideoPicture;

/**
 * Defines the events that be generated by an {@link IMediaGenerator}.
 * 
 * <p>
 * 
 * You can use objects that implement this interface to listen to events
 * generated by an {@link IMediaGenerator} object. To do that, create your
 * {@link IMediaListener} object and attach it to an {@link IMediaGenerator} by
 * calling {@link IMediaGenerator#addListener(IMediaListener)}.
 * 
 * </p>
 * <p>
 * 
 * These methods block the calling {@link IMediaGenerator} while they process so try
 * to return quickly. If you have long running actions to perform, use a
 * separate thread.
 * 
 * </p>
 */

public interface IMediaListener
{
  
  /**
   * Base class for all IMediaEvents that {@link IMediaListener}s
   * can listen for.
   * @author aclarke
   *
   */
  public class MediaEvent
  {
    private final IMediaGenerator mSource;
    public MediaEvent(IMediaGenerator source)
    {
      mSource = source;
    }
    /**
     * Get the source of this event.
     * @return the source
     */
    public IMediaGenerator getSource()
    {
      return mSource;
    }
    
  }
  
  /**
   * {@link MediaEvent} for {@link IMediaListener#onVideoPicture(MediaVideoPictureEvent)}
   * 
   * @author aclarke
   *
   */
  public class MediaVideoPictureEvent extends MediaEvent
  {
    private final IVideoPicture mVideoPicture;
    private final BufferedImage mBufferedImage;
    private final long mTimeStamp;
    private final TimeUnit mTimeUnit;
    private final int mStreamIndex;

    public MediaVideoPictureEvent(IMediaGenerator source, 
        IVideoPicture picture, BufferedImage image,
        long timeStamp, TimeUnit timeUnit,
        int streamIndex)
    {
      super(source);
      if (image == null && picture == null)
        throw new IllegalArgumentException();
      mVideoPicture = picture;
      mBufferedImage = image;
      if (image == null)
      {
        timeStamp = picture.getTimeStamp();
        timeUnit = TimeUnit.MICROSECONDS;
      }
      mTimeStamp = timeStamp;
      if (timeUnit == null)
        throw new IllegalArgumentException();
      mTimeUnit = timeUnit;
      mStreamIndex = streamIndex;
    }
    public MediaVideoPictureEvent(IMediaGenerator source,
        IVideoPicture picture, int streamIndex)
    {
      this(source, picture, null, 0, null, streamIndex);
    }
    public MediaVideoPictureEvent(IMediaGenerator source,
        BufferedImage image, long timeStamp, TimeUnit timeUnit,
        int streamIndex)
    {
      this(source, null, image, timeStamp, timeUnit, streamIndex);
    }

    /**
     * The video picture.  May be null if {@link #getBufferedImage()}
     * is not null.
     * <p>
     * The returned {@link IVideoPicture} will only be valid for
     * the duration of the {@link IMediaListener#onVideoPicture(MediaVideoPictureEvent)}
     * call, and {@link IMediaListener} implementations must not use it after
     * the call returns.  If you need to keep a copy of this data then
     * use {@link IVideoPicture#copyReference()} to create a reference
     * that will outlive your call.
     * </p>
     * 
     * @return the videoPicture, or null if unavailable
     */
    public IVideoPicture getVideoPicture()
    {
      return mVideoPicture;
    }

    /**
     * The buffered image, if available.  If null,
     * you must use {@link #getVideoPicture()}
     * @return the bufferedImage, or null if not available
     */
    public BufferedImage getBufferedImage()
    {
      return mBufferedImage;
    }

    /**
     * The time stamp of this media, in {@link TimeUnit#MICROSECONDS}.
     * @return the timeStamp
     */
    public long getTimeStamp()
    {
      return TimeUnit.MICROSECONDS.convert(mTimeStamp, mTimeUnit);
    }
    /**
     * Get the time stamp of this media in the specified units.
     * @param unit the time unit
     * @return the time stamp
     * @throws IllegalArgumentException if unit is null
     */
    public long getTimeStamp(TimeUnit unit)
    {
      if (unit == null)
        throw new IllegalArgumentException();
      return unit.convert(mTimeStamp, mTimeUnit);
    }

    /**
     * The time unit of {@link #getTimeStamp()}.
     * @return the timeUnit
     */
    public TimeUnit getTimeUnit()
    {
      return mTimeUnit;
    }

    /**
     * @return the streamIndex
     */
    public int getStreamIndex()
    {
      return mStreamIndex;
    }
  }
  
  
  /**
   * Called after a video picture has been decoded by a {@link IMediaReader} or
   * encoded by a {@link IMediaWriter}.
   * 
   * @param event An event containing either an {@link IVideoPicture},
   *   a {@link BufferedImage}, or both.
   */

  public void onVideoPicture(MediaVideoPictureEvent event);

  /**
   * Called after audio samples have been decoded or encoded by an
   * {@link IMediaGenerator}
   * 
   * @param pipe the pipe that generated this event
   * @param samples a set of audio samples. The samples will only be valid for
   *        the duration of this call. If you need to remember the data, you
   *        must either copy it out of the {@link IAudioSamples} object into
   *        your own object, or use {@link IAudioSamples#copyReference()} to
   *        create a new object you can own that points to the same
   *        memory as samples.
   * @param streamIndex the index of the stream
   */

  public void onAudioSamples(IMediaGenerator pipe, IAudioSamples samples,
      int streamIndex);

  /**
   * Called after an {@link IMediaGenerator} is opened.
   * 
   * @param pipe the pipe that generated this event
   */

  public void onOpen(IMediaGenerator pipe);

  /**
   * Called after an {@link IMediaGenerator} is closed.
   * 
   * @param pipe the pipe that generated this event
   */

  public void onClose(IMediaGenerator pipe);

  /**
   * Called after an stream is added to an {@link IMediaGenerator}. This occurs when
   * a new stream is added (if writing) or encountered by the pipe (if reading).
   * If the stream is not already been opened, then
   * {@link #onOpenCoder(IMediaGenerator, Integer)} will be called at some later
   * point.
   * 
   * @param pipe the pipe that generated this event
   * @param streamIndex the stream opened
   */

  public void onAddStream(IMediaGenerator pipe, int streamIndex);

  /**
   * Called after a decoder or encoder is opened by a {@link IMediaGenerator}
   * 
   * @param pipe the pipe that generated this event
   * @param coderIndex an index for this coder if known, or null if not.
   */

  public void onOpenCoder(IMediaGenerator pipe, Integer coderIndex);

  /**
   * Called after an decoder or encoder is closed by the {@link IMediaGenerator}.
   * 
   * @param pipe the pipe that generated this event
   * @param coderIndex an index for this coder if known, or null if not.
   */

  public void onCloseCoder(IMediaGenerator pipe, Integer coderIndex);

  /**
   * Called after a {@link com.xuggle.xuggler.IPacket} has been read by a
   * {@link IMediaReader}.
   * 
   * @param pipe the pipe that generated this event
   * @param packet the packet just read. This {@link IPacket} is only valid for
   *        the duration of this call. If you need to use the data after this
   *        call has returned, you must either copy the data in this call, or
   *        use {@link IPacket#copyReference()} to create a new object
   *        with a reference you can own.
   */

  public void onReadPacket(IMediaGenerator pipe, IPacket packet);

  /**
   * Called after a {@link com.xuggle.xuggler.IPacket} has been written by a
   * {@link IMediaWriter}.
   * 
   * @param pipe the pipe that generated this event
   * @param packet the packet just written. This {@link IPacket} is only valid
   *        for the duration of this call. If you need to use the data after
   *        this call has returned, you must either copy the data in this call,
   *        or use {@link IPacket#copyReference()} to create a new object
   *        with a reference you can own.
   */

  public void onWritePacket(IMediaGenerator pipe, IPacket packet);

  /**
   * Called after a {@link IMediaWriter} writes the header.
   * 
   * @param pipe the pipe that generated this event
   */

  public void onWriteHeader(IMediaGenerator pipe);

  /**
   * Called after a {@link IMediaWriter} has flushed its buffers.
   * 
   * @param pipe the pipe that generated this event
   */

  public void onFlush(IMediaGenerator pipe);

  /**
   * Called after a {@link IMediaWriter} writes the trailer.
   * 
   * @param pipe the pipe that generated this event
   */

  public void onWriteTrailer(IMediaGenerator pipe);
}
