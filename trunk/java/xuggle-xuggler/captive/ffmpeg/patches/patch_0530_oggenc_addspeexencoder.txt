Index: libavformat/oggenc.c
===================================================================
--- libavformat/oggenc.c	(revision 19361)
+++ libavformat/oggenc.c	(working copy)
@@ -83,6 +83,35 @@
     return size;
 }
 
+static int ogg_build_speex_headers(AVCodecContext *avctx,
+                                   OGGStreamContext *oggstream, int bitexact)
+{
+    const char *vendor = bitexact ? "ffmpeg" : LIBAVFORMAT_IDENT;
+    uint8_t *p;
+
+    // first packet: SpeexHeader per Speex docs
+    oggstream->header_len[0] = avctx->extradata_size;
+    oggstream->header[0] = av_mallocz(oggstream->header_len[0]); 
+    p = oggstream->header[0];
+    if (!p)
+        return AVERROR_NOMEM;
+    memcpy(oggstream->header[0], avctx->extradata, avctx->extradata_size);
+
+    // second packet: VorbisComment
+    oggstream->header_len[1] = 1+3+4+strlen(vendor)+4;
+    oggstream->header[1] = av_mallocz(oggstream->header_len[1]);
+    p = oggstream->header[1];
+    if (!p)
+        return AVERROR_NOMEM;
+    bytestream_put_byte(&p, 0x84); // last metadata block and vorbis comment
+    bytestream_put_be24(&p, oggstream->header_len[1] - 4);
+    bytestream_put_le32(&p, strlen(vendor));
+    bytestream_put_buffer(&p, vendor, strlen(vendor));
+    bytestream_put_le32(&p, 0); // user comment list length
+
+    return 0;
+}
+
 static int ogg_build_flac_headers(AVCodecContext *avctx,
                                   OGGStreamContext *oggstream, int bitexact)
 {
@@ -137,7 +166,8 @@
             av_set_pts_info(st, 64, st->codec->time_base.num, st->codec->time_base.den);
         if (st->codec->codec_id != CODEC_ID_VORBIS &&
             st->codec->codec_id != CODEC_ID_THEORA &&
-            st->codec->codec_id != CODEC_ID_FLAC) {
+            st->codec->codec_id != CODEC_ID_FLAC &&
+            st->codec->codec_id != CODEC_ID_SPEEX ) {
             av_log(s, AV_LOG_ERROR, "Unsupported codec id in stream %d\n", i);
             return -1;
         }
@@ -156,6 +186,15 @@
                 av_freep(&st->priv_data);
                 return err;
             }
+        } else if (st->codec->codec_id == CODEC_ID_SPEEX) {
+          // extradata should have the speex header
+          int err = ogg_build_speex_headers(st->codec, oggstream,
+                                            st->codec->flags & CODEC_FLAG_BITEXACT);
+          if (err) {
+              av_log(s, AV_LOG_ERROR, "Error writing Speex headers\n");
+              av_freep(&st->priv_data);
+              return err;
+          }
         } else {
             if (ff_split_xiph_headers(st->codec->extradata, st->codec->extradata_size,
                                       st->codec->codec_id == CODEC_ID_VORBIS ? 30 : 42,
@@ -275,7 +314,8 @@
     for (i = 0; i < s->nb_streams; i++) {
         AVStream *st = s->streams[i];
         OGGStreamContext *oggstream = st->priv_data;
-        if (st->codec->codec_id == CODEC_ID_FLAC) {
+        if (st->codec->codec_id == CODEC_ID_FLAC ||
+            st->codec->codec_id == CODEC_ID_SPEEX) {
             av_free(oggstream->header[0]);
             av_free(oggstream->header[1]);
         }
