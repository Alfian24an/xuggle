/*
 * Copyright (c) 2008, 2009 by Xuggle Incorporated. All rights reserved.
 * 
 * This file is part of Xuggler.
 * 
 * You can redistribute Xuggler and/or modify it under the terms of the GNU
 * Affero General Public License as published by the Free Software Foundation,
 * either version 3 of the License, or (at your option) any later version.
 * 
 * Xuggler is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU Affero General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU Affero General Public License
 * along with Xuggler. If not, see <http://www.gnu.org/licenses/>.
 */

package com.xuggle.mediatool;

import java.awt.image.BufferedImage;
import java.util.concurrent.TimeUnit;

import com.xuggle.xuggler.IPacket;
import com.xuggle.xuggler.IAudioSamples;
import com.xuggle.xuggler.IVideoPicture;

/**
 * Defines the events that be generated by an {@link IMediaPipe}.
 * 
 * <p>
 * 
 * You can use objects that implement this interface to listen to events
 * generated by an {@link IMediaPipe} object. To do that, create your
 * {@link IMediaPipeListener} object and attach it to an {@link IMediaPipe} by
 * calling {@link IMediaPipe#addListener(IMediaPipeListener)}.
 * 
 * </p>
 * <p>
 * 
 * These methods block the calling {@link IMediaPipe} while they process so try
 * to return quickly. If you have long running actions to perform, use a
 * separate thread.
 * 
 * </p>
 */

public interface IMediaPipeListener
{
  /**
   * Called after a video picture has been decoded by a {@link IMediaReader} or
   * encoded by a {@link IMediaWriter}.
   * 
   * <p>
   * 
   * Generators of this event will guarantee that either <code>picture</code> or
   * <code>image</code> will be non-null. If both are non-null, then
   * <code>image</code> should be assumed to be the correct data and
   * <code>picture</code> should be ignored.
   * 
   * </p>
   * 
   * @param pipe the pipe that generated this event
   * @param picture a raw video picture. This picture will only be valid for the
   *        duration of this call. If you need to remember the data, you must
   *        either copy it out of the video picture, or use
   *        {@link IVideoPicture#copyReference()} to create a new object that
   *        points to the same memory as picture.
   * @param image if not null, then this represents the image data encoded or
   *        decoded.
   * @param timeStamp if image is not null, this is the timeStamp for image;
   *        else this value should be ignored
   * @param timeUnit if image is not null, this is the timeUnit of timeStamp
   *        else this value should be ignored
   * @param streamIndex the index of the stream this object was decoded from.
   */

  public void onVideoPicture(IMediaPipe pipe, IVideoPicture picture,
      BufferedImage image, long timeStamp, TimeUnit timeUnit, int streamIndex);

  /**
   * Called after audio samples have been decoded or encoded by an
   * {@link IMediaPipe}
   * 
   * @param pipe the pipe that generated this event
   * @param samples a set of audio samples. The samples will only be valid for
   *        the duration of this call. If you need to remember the data, you
   *        must either copy it out of the {@link IAudioSamples} object into
   *        your own object, or use {@link IAudioSamples#copyReference()} to
   *        create a new object you can own that points to the same
   *        memory as samples.
   * @param streamIndex the index of the stream
   */

  public void onAudioSamples(IMediaPipe pipe, IAudioSamples samples,
      int streamIndex);

  /**
   * Called after an {@link IMediaPipe} is opened.
   * 
   * @param pipe the pipe that generated this event
   */

  public void onOpen(IMediaPipe pipe);

  /**
   * Called after an {@link IMediaPipe} is closed.
   * 
   * @param pipe the pipe that generated this event
   */

  public void onClose(IMediaPipe pipe);

  /**
   * Called after an stream is added to an {@link IMediaPipe}. This occurs when
   * a new stream is added (if writing) or encountered by the pipe (if reading).
   * If the stream is not already been opened, then
   * {@link #onOpenCoder(IMediaPipe, Integer)} will be called at some later
   * point.
   * 
   * @param pipe the pipe that generated this event
   * @param streamIndex the stream opened
   */

  public void onAddStream(IMediaPipe pipe, int streamIndex);

  /**
   * Called after a decoder or encoder is opened by a {@link IMediaPipe}
   * 
   * @param pipe the pipe that generated this event
   * @param coderIndex an index for this coder if known, or null if not.
   */

  public void onOpenCoder(IMediaPipe pipe, Integer coderIndex);

  /**
   * Called after an decoder or encoder is closed by the {@link IMediaPipe}.
   * 
   * @param pipe the pipe that generated this event
   * @param coderIndex an index for this coder if known, or null if not.
   */

  public void onCloseCoder(IMediaPipe pipe, Integer coderIndex);

  /**
   * Called after a {@link com.xuggle.xuggler.IPacket} has been read by a
   * {@link IMediaReader}.
   * 
   * @param pipe the pipe that generated this event
   * @param packet the packet just read. This {@link IPacket} is only valid for
   *        the duration of this call. If you need to use the data after this
   *        call has returned, you must either copy the data in this call, or
   *        use {@link IPacket#copyReference()} to create a new object
   *        with a reference you can own.
   */

  public void onReadPacket(IMediaPipe pipe, IPacket packet);

  /**
   * Called after a {@link com.xuggle.xuggler.IPacket} has been written by a
   * {@link IMediaWriter}.
   * 
   * @param pipe the pipe that generated this event
   * @param packet the packet just written. This {@link IPacket} is only valid
   *        for the duration of this call. If you need to use the data after
   *        this call has returned, you must either copy the data in this call,
   *        or use {@link IPacket#copyReference()} to create a new object
   *        with a reference you can own.
   */

  public void onWritePacket(IMediaPipe pipe, IPacket packet);

  /**
   * Called after a {@link IMediaWriter} writes the header.
   * 
   * @param pipe the pipe that generated this event
   */

  public void onWriteHeader(IMediaPipe pipe);

  /**
   * Called after a {@link IMediaWriter} has flushed its buffers.
   * 
   * @param pipe the pipe that generated this event
   */

  public void onFlush(IMediaPipe pipe);

  /**
   * Called after a {@link IMediaWriter} writes the trailer.
   * 
   * @param pipe the pipe that generated this event
   */

  public void onWriteTrailer(IMediaPipe pipe);
}
