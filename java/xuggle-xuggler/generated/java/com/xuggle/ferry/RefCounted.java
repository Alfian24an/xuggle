/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3.37
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package com.xuggle.ferry;

/**
 * RefCounted is the parent class of <b>every</b> native object  
 * that is passed into and out of Java.  
 * <p>  
 * RefCounted objects cannot be made with new. They must be  
 * constructed with special factory methods, usually called  
 * make(...).  
 * </p>  
 * <p>  
 * Users of RefCounted objects in Native (C++) code must make  
 * sure they #acquire() a reference to an object if they  
 * intend to keep using it after it is passed to them, and  
 * must call #release() when done to ensure memory is freed.  
 * </p>  
 * <p>  
 * Methods that return RefCounted objects on the stack are  
 * expected to #acquire() the reference for the caller, and  
 * callers <b>must</b> #release() any RefCounted object  
 * returned on the stack.  
 * <p>  
 * For example:  
 * </p>  
 * <code>  
 * <pre>  
 * RefCounted methodReturningRefCountedObject();  
 * {  
 * mValueToReturn->acquire(); acquire for caller  
 * return mValueToReturn; and return  
 * }  
 * {  
 * RefCounted = methodReturningRefCountedObject();  
 * ...  
 * caller must release  
 * if (value)  
 * value->release();  
 * }  
 * </pre>  
 * </code>  
 * If you're using from Java you don't need to worry about  
 * this; the JVM will release correctly for you (in fact,  
 * that's the whole reason this class exists).  
 */
public class RefCounted {
  // JNIHelper.swg: Start generated code
  // >>>>>>>>>>>>>>>>>>>>>>>>>>>
  private volatile long swigCPtr;
  protected boolean swigCMemOwn;
  private com.xuggle.ferry.JNIReference mRefCounter;
  private Long mLifecycleReference;
  
  // the next object looks like it is unused by the compiler, but that's not true; it most
  // definitely is used :)
  @SuppressWarnings("unused")
  private com.xuggle.ferry.JNINativeFinalizer mObjectToForceFinalize;

  /**
   * Not part of public API.
   */
  protected RefCounted(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
    if (swigCPtr != 0)
    {
      // This object must:
      // (a) have no references to any other java object
      // (b) Have a finalizer that just calls gc() on our JNIMemoryManager
      // It exists only to force gc() to be called even if someone calls the Xuggle
      // libraries once and never again
      mObjectToForceFinalize = new com.xuggle.ferry.JNINativeFinalizer();
      // This is what the weak reference will watch; this object should
      // (a) have no references to any other Java object
      // (b) MUST NOT have a finalizer
      // (c) MUST NOT acquire any other references to it except for the strong reference
      //     right here, and the weak reference in mRefCounter
      mLifecycleReference = new Long(swigCPtr);      
      // Force the creation of a new weak reference, will will actually pin itself
      // inside the reference class.
      mRefCounter = JNIReference.createReference(mLifecycleReference, swigCPtr);
    }
  }

  /**
   * Not part of public API.
   *
   * Get the raw value of the native object that obj is proxying for.
   *   
   * @param obj The java proxy object for a native object.
   * @return The raw pointer obj is proxying for.
   */
  public static long getCPtr(RefCounted obj) {
    if (obj == null) return 0;
    return obj.getMyCPtr();
  }
  
  /**
   * Not part of public API.
   *
   * Get the raw value of the native object that we're proxying for.
   *   
   * @return The raw pointer we're proxying for.
   */
  public long getMyCPtr() {
    if (swigCPtr == 0) throw new NullPointerException("underlying native object already deleted");
    return swigCPtr;
  }
  
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<
  // JNIHelper.swg: End generated code
 
  public synchronized void delete() 
  // JNIHelper.swg: Start generated code
  // >>>>>>>>>>>>>>>>>>>>>>>>>>>
  {
    if(swigCPtr != 0) {
      // assigning to an object removes an incorrect java
      // compiler warning for some
      // generated files
      Object object = this;
      if (object instanceof RefCounted && mRefCounter != null) {
        mRefCounter.delete();
      } else if (swigCMemOwn) {
        swigCMemOwn = false;
        throw new UnsupportedOperationException("C++ destructor does not have public access");
      }
    }
    mRefCounter = null;
    mObjectToForceFinalize = null;
    mLifecycleReference = null;
    swigCPtr = 0;
  }
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<
  // JNIHelper.swg: End generated code


/**
 * Acquire a reference to this object (only called from Native code). 
 *  
 * This increments the internal ref count by +1  
 * @return	The refcount after the acquire. Note due to multi-threaded 
 *		 issues, you should not rely on this value.  
 */
  protected int acquire() {
    return FerryJNI.RefCounted_acquire(swigCPtr, this);
  }

/**
 * Release a reference to this object (only called from Native code). 
 *  
 * This decrements the internal ref count by -1; the object  
 * is destroyed if it's ref count reaches zero.  
 * @return	The ref count after the release. Note due to multi-threaded 
 *		 issues, you should not rely on this value.  
 */
  protected int release() {
    return FerryJNI.RefCounted_release(swigCPtr, this);
  }

/**
 *  
 * This method is meant for other language use like Java; it  
 * will acquire the object but also force the creation of  
 * a new object in the target language when wrapped with  
 * SWIG.  
 * <p>  
 * It is not meant for calling from C++ code; use the  
 * standard acquire and release semantics for that.  
 * </p>  
 * @return	A new Java object.  
 */
  public RefCounted copyReference() {
    long cPtr = FerryJNI.RefCounted_copyReference(swigCPtr, this);
    return (cPtr == 0) ? null : new RefCounted(cPtr, false);
  }

/**
 * Return the current reference count on this object.  
 * The number returned represents the value at the instant  
 * the message was called, and the value can change even  
 * before this method returns. Callers are advised not to  
 * depend on the value of this except to check that  
 * the value == 1.  
 * <p>  
 * If the value returned is one, and you know you have a valid  
 * reference to that object, then congratulations; you are the  
 * only person referencing that object.  
 * </p>  
 * @return	The current ref count.  
 */
  public int getCurrentRefCount() {
    return FerryJNI.RefCounted_getCurrentRefCount(swigCPtr, this);
  }

}
