/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3.37
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package com.xuggle.xuggler;
import com.xuggle.ferry.*;
/**
 * This class wraps represents a Rational number for the Xuggler.  
 * <p>  
 * Video formats often use rational numbers, and converting between 
 *  
 * them willy nilly can lead to rounding errors, and eventually, out 
 *  
 * of sync problems. Therefore we use IRational objects to pass  
 * around Rational Numbers and avoid conversion until the very last 
 * moment.  
 * </p><p>  
 * Note: There are some static convenience methods  
 * in this class that start with s*. They start with s  
 * (as opposed to overloading methods (e.g. sAdd(...) vs. add(...)) 
 *  
 * because SWIG doesn't support static overloaded methods.  
 * </p>  
 */
public class IRational extends RefCounted {
  // JNIHelper.swg: Start generated code
  // >>>>>>>>>>>>>>>>>>>>>>>>>>>
  /**
   * This method is only here to use some references and remove
   * a Eclipse compiler warning.
   */
  @SuppressWarnings("unused")
  private void noop()
  {
    IBuffer.make(null, 1);
  }
   
  private volatile long swigCPtr;

  protected IRational(long cPtr, boolean cMemoryOwn) {
    super(XugglerJNI.SWIGIRationalUpcast(cPtr), cMemoryOwn);
    swigCPtr = cPtr;
  }
  
  /**
   * Not part of public API.
   *
   * Get the raw value of the native object that obj is proxying for.
   *   
   * @param obj The java proxy object for a native object.
   * @return The raw pointer obj is proxying for.
   */
  public static long getCPtr(IRational obj) {
    if (obj == null) return 0;
    return obj.getMyCPtr();
  }

  /**
   * Not part of public API.
   *
   * Get the raw value of the native object that we're proxying for.
   *   
   * @return The raw pointer we're proxying for.
   */  
  public long getMyCPtr() {
    if (swigCPtr == 0) throw new IllegalStateException("underlying native object already deleted");
    return swigCPtr;
  }
  
  /**
   * Create a new IRational object that is actually referring to the
   * exact same underlying Native object.
   *
   * This method increases the ref count of the underlying Native object.
   *
   * @return the new Java object.
   */
  public IRational copyReference() {
    if (swigCPtr == 0)
      return null;
    else
    {
      IRational retval = new IRational(swigCPtr, false);
      retval.acquire();
      return retval;
    }
  }

  /**
   * Compares two values, returning true if the underlying objects in native code are the same object.
   *
   * That means you can have two different Java objects, but when you do a comparison, you'll find out
   * they are the EXACT same object.
   *
   * @return True if the underlying native object is the same.  False otherwise.
   */
  public boolean equals(Object obj) {
    boolean equal = false;
    if (obj instanceof IRational)
      equal = (((IRational)obj).swigCPtr == this.swigCPtr);
    return equal;
  }
  
  /**
   * Get a hashable value for this object.
   *
   * @return the hashable value.
   */
  public int hashCode() {
     return (int)swigCPtr;
  }
  
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<
  // JNIHelper.swg: End generated code

  public synchronized void delete() {
    if(swigCPtr != 0 && swigCMemOwn) {
      swigCMemOwn = false;
      throw new UnsupportedOperationException("C++ destructor does not have public access");
    }
    swigCPtr = 0;
    super.delete();
  }


  /**
   * Prints the contents of this object as a fraction.
   * @return &quot;{@link #getNumerator()}/{@link #getDenominator()}&quot;
   */
   
  @Override
  public String toString()
  {
    return "" + getNumerator() + "/" + getDenominator();
  }


  public int getNumerator() {
    return XugglerJNI.IRational_getNumerator(swigCPtr, this);
  }

  public int getDenominator() {
    return XugglerJNI.IRational_getDenominator(swigCPtr, this);
  }

/**
 * Creates a new IRational object by copying (by value) this object. 
 *  
 * @return	the new object  
 */
  public IRational copy() {
    long cPtr = XugglerJNI.IRational_copy(swigCPtr, this);
    return (cPtr == 0) ? null : new IRational(cPtr, false);
  }

/**
 * Compare a rational to this rational  
 * @param	other second rational  
 *  
 */
  public int compareTo(IRational other) {
    return XugglerJNI.IRational_compareTo(swigCPtr, this, IRational.getCPtr(other), other);
  }

  public static int sCompareTo(IRational a, IRational b) {
    return XugglerJNI.IRational_sCompareTo(IRational.getCPtr(a), a, IRational.getCPtr(b), b);
  }

/**
 * Rational to double conversion.  
 * @return	(double) a  
 */
  public double getDouble() {
    return XugglerJNI.IRational_getDouble(swigCPtr, this);
  }

/**
 * Reduce a fraction.  
 * This is useful for framerate calculations.  
 * @param	num the src numerator.  
 * @param	den the src denominator.  
 * @param	max the maximum allowed for nom & den in the reduced fraction. 
 *		  
 * @return	1 if exact, 0 otherwise  
 */
  public int reduce(long num, long den, long max) {
    return XugglerJNI.IRational_reduce(swigCPtr, this, num, den, max);
  }

  public static int sReduce(IRational dst, long num, long den, long max) {
    return XugglerJNI.IRational_sReduce(IRational.getCPtr(dst), dst, num, den, max);
  }

/**
 * Multiplies this number by arg  
 * @param	arg number to mulitply by.  
 * @return	this*arg. Note caller must release() the return value.  
 */
  public IRational multiply(IRational arg) {
    long cPtr = XugglerJNI.IRational_multiply(swigCPtr, this, IRational.getCPtr(arg), arg);
    return (cPtr == 0) ? null : new IRational(cPtr, false);
  }

  public static IRational sMultiply(IRational a, IRational b) {
    long cPtr = XugglerJNI.IRational_sMultiply(IRational.getCPtr(a), a, IRational.getCPtr(b), b);
    return (cPtr == 0) ? null : new IRational(cPtr, false);
  }

/**
 * Divides this rational by arg.  
 * @param	arg The divisor to use.  
 * @return	this/arg.  
 */
  public IRational divide(IRational arg) {
    long cPtr = XugglerJNI.IRational_divide(swigCPtr, this, IRational.getCPtr(arg), arg);
    return (cPtr == 0) ? null : new IRational(cPtr, false);
  }

  public static IRational sDivide(IRational a, IRational b) {
    long cPtr = XugglerJNI.IRational_sDivide(IRational.getCPtr(a), a, IRational.getCPtr(b), b);
    return (cPtr == 0) ? null : new IRational(cPtr, false);
  }

/**
 * Subtracts arg from this rational  
 * @param	arg The amount to subtract from this.  
 * @return	this-arg.  
 */
  public IRational subtract(IRational arg) {
    long cPtr = XugglerJNI.IRational_subtract(swigCPtr, this, IRational.getCPtr(arg), arg);
    return (cPtr == 0) ? null : new IRational(cPtr, false);
  }

  public static IRational sSubtract(IRational a, IRational b) {
    long cPtr = XugglerJNI.IRational_sSubtract(IRational.getCPtr(a), a, IRational.getCPtr(b), b);
    return (cPtr == 0) ? null : new IRational(cPtr, false);
  }

/**
 * Adds arg to this rational  
 * @param	arg The amount to add to this.  
 * @return	this+arg.  
 */
  public IRational add(IRational arg) {
    long cPtr = XugglerJNI.IRational_add(swigCPtr, this, IRational.getCPtr(arg), arg);
    return (cPtr == 0) ? null : new IRational(cPtr, false);
  }

  public static IRational sAdd(IRational a, IRational b) {
    long cPtr = XugglerJNI.IRational_sAdd(IRational.getCPtr(a), a, IRational.getCPtr(b), b);
    return (cPtr == 0) ? null : new IRational(cPtr, false);
  }

/**
 * Takes a value scaled in increments of origBase and gives the  
 * equivalent value scaled in terms of this Rational.  
 * @param	origValue The original int64_t value you care about.  
 * @param	origBase The original base Rational that origValue is scaled 
 *		 with.  
 * @return	The new integer value, scaled in units of this IRational. 
 *		  
 */
  public long rescale(long origValue, IRational origBase) {
    return XugglerJNI.IRational_rescale(swigCPtr, this, origValue, IRational.getCPtr(origBase), origBase);
  }

  public static long sRescale(long origValue, IRational origBase, IRational newBase) {
    return XugglerJNI.IRational_sRescale(origValue, IRational.getCPtr(origBase), origBase, IRational.getCPtr(newBase), newBase);
  }

/**
 * Get a new rational that will be set to 0/0.  
 * @return	a rational number object  
 */
  public static IRational make() {
    long cPtr = XugglerJNI.IRational_make__SWIG_0();
    return (cPtr == 0) ? null : new IRational(cPtr, false);
  }

/**
 * Converts a double precision floating point number to a rational. 
 *  
 * @param	d double to convert  
 * @return	A new Rational; caller must release() when done.  
 */
  public static IRational make(double d) {
    long cPtr = XugglerJNI.IRational_make__SWIG_1(d);
    return (cPtr == 0) ? null : new IRational(cPtr, false);
  }

/**
 * Creates copy of a Rational from another Rational.  
 * Note: This is a NEW object. To just keep tabs on the  
 * original, use acquire() to keep a reference.  
 * @param	src The source Rational to copy.  
 * @return	A new Rational; caller must call release. Returns null  
 * if src is null.  
 */
  public static IRational make(IRational src) {
    long cPtr = XugglerJNI.IRational_make__SWIG_2(IRational.getCPtr(src), src);
    return (cPtr == 0) ? null : new IRational(cPtr, false);
  }

/**
 * Create a rational from a numerator and denominator.  
 * We will always reduce this to the lowest num/den pair  
 * we can, but never having den exceed what was passed in.  
 * @param	num The numerator of the resulting Rational  
 * @param	den The denominator of the resulting Rational  
 * @return	A new Rational; caller must call release.  
 */
  public static IRational make(int num, int den) {
    long cPtr = XugglerJNI.IRational_make__SWIG_3(num, den);
    return (cPtr == 0) ? null : new IRational(cPtr, false);
  }

}
